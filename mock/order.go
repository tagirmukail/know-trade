// Code generated by MockGen. DO NOT EDIT.
// Source: internal/exchange/exchange.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	types "github.com/tgmk/know-trade/internal/types"
)

// MockOrder is a mock of Order interface
type MockOrder struct {
	ctrl     *gomock.Controller
	recorder *MockOrderMockRecorder
}

// MockOrderMockRecorder is the mock recorder for MockOrder
type MockOrderMockRecorder struct {
	mock *MockOrder
}

// NewMockOrder creates a new mock instance
func NewMockOrder(ctrl *gomock.Controller) *MockOrder {
	mock := &MockOrder{ctrl: ctrl}
	mock.recorder = &MockOrderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockOrder) EXPECT() *MockOrderMockRecorder {
	return m.recorder
}

// Market mocks base method
func (m *MockOrder) Market(ctx context.Context, symbol, side string, size float64) (*types.Order, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Market", ctx, symbol, side, size)
	ret0, _ := ret[0].(*types.Order)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Market indicates an expected call of Market
func (mr *MockOrderMockRecorder) Market(ctx, symbol, side, size interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Market", reflect.TypeOf((*MockOrder)(nil).Market), ctx, symbol, side, size)
}

// Limit mocks base method
func (m *MockOrder) Limit(ctx context.Context, symbol, side string, price, size float64) (*types.Order, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Limit", ctx, symbol, side, price, size)
	ret0, _ := ret[0].(*types.Order)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Limit indicates an expected call of Limit
func (mr *MockOrderMockRecorder) Limit(ctx, symbol, side, price, size interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Limit", reflect.TypeOf((*MockOrder)(nil).Limit), ctx, symbol, side, price, size)
}

// Cancel mocks base method
func (m *MockOrder) Cancel(ctx context.Context, orderID string) (*types.Order, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cancel", ctx, orderID)
	ret0, _ := ret[0].(*types.Order)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Cancel indicates an expected call of Cancel
func (mr *MockOrderMockRecorder) Cancel(ctx, orderID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancel", reflect.TypeOf((*MockOrder)(nil).Cancel), ctx, orderID)
}
